import { NextRequest, NextResponse } from "next/server"
import { google } from "googleapis"
import { getServerSession, getGoogleAccessToken } from "@/lib/auth-supabase"
import { createSupabaseServerClient } from "@/lib/supabase-server"

export async function POST(_req: NextRequest) {
  try {
    const session = await getServerSession()
    if (!session?.user?.email || !session.user.id) {
      return NextResponse.json({ error: "Not authenticated" }, { status: 401 })
    }

    const userEmail = session.user.email
    // Prefer COMPANY_DOMAIN env, else derive from email
    const envDomain = process.env.COMPANY_DOMAIN?.trim()
    const domain = envDomain || userEmail.split("@")[1]
    if (!domain) {
      return NextResponse.json({ message: "No domain found, skipping" })
    }

    const accessToken = await getGoogleAccessToken()
    if (!accessToken) {
      return NextResponse.json({ error: "Missing Google access token" }, { status: 400 })
    }

    // Google Calendar client
    const auth = new google.auth.OAuth2()
    auth.setCredentials({ access_token: accessToken })
    const calendar = google.calendar({ version: "v3", auth })

    const now = new Date()
    const past = new Date(now.getTime() - 60 * 24 * 60 * 60 * 1000) // last 60 days

    // List events in last 60 days from primary calendar
    const eventsRes = await calendar.events.list({
      calendarId: "primary",
      timeMin: past.toISOString(),
      timeMax: now.toISOString(),
      singleEvents: true,
      maxResults: 2500,
      orderBy: "startTime",
    })

    const emails = new Set<string>()
    const names = new Map<string, string | undefined>()

    for (const ev of eventsRes.data.items || []) {
      const attendees = ev.attendees || []
      for (const a of attendees) {
        const email = a.email?.toLowerCase()
        if (!email) continue
        if (email === userEmail.toLowerCase()) continue
        if (email.endsWith(`@${domain}`)) {
          emails.add(email)
          if (a.displayName && !names.has(email)) names.set(email, a.displayName)
        }
      }
    }

    if (emails.size === 0) {
      return NextResponse.json({ message: "No teammates discovered" })
    }

    const supabase = await createSupabaseServerClient()

    const upserts = Array.from(emails).map((email) => ({
      email,
      name: names.get(email) || null,
      image_url: null,
      domain,
    }))

    // Upsert discovered users by email (id will be generated by DB if needed)
    const { error } = await supabase
      .from("users")
      .upsert(upserts, { onConflict: "email" })

    if (error) {
      console.error("Upsert teammates error:", error)
      return NextResponse.json({ error: "Failed to upsert teammates" }, { status: 500 })
    }

    return NextResponse.json({ message: "Bootstrapped teammates", count: emails.size })
  } catch (e) {
    console.error("bootstrap-team error", e)
    return NextResponse.json({ error: "Internal server error" }, { status: 500 })
  }
}


